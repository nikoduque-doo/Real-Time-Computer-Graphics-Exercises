{"camera":{"position":[-5.930786406335516,8.411063629262149,-40.33707700400393],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","blendEnable":true,"blendOperation":"FUNC_ADD","srcColorBlendFactor":"SRC_ALPHA","dstColorBlendFactor":"ONE_MINUS_SRC_ALPHA","srcAlphaBlendFactor":"SRC_ALPHA","dstAlphaBlendFactor":"ONE_MINUS_SRC_ALPHA","textureFiltering":"LINEAR_MIPMAP_LINEAR","maxAnisotropy":"1"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex position in object space coordinates\nin vec3 vertexPosition;\n// Surface normal at the vertex in object space coordinates\nin vec3 vertexNormal;\n// Texture coordinates at that vertex\nin vec2 vertexTextureCoordinates;\n\nout vec3 fragmentPosition;\nout vec3 fragmentNormal;\nout vec3 viewDirection;\nout vec3 lightDirection;\n\n// Model matrix\nuniform mat4 mMatrix;\n// View matrix\nuniform mat4 vMatrix;\n// Projection matrix\nuniform mat4 pMatrix;\n// Light Position\nuniform vec3 lightPosition;\n\n\n// Main program for each vertex\nvoid main() {\n  vec4 vertexCamSpace = vMatrix * mMatrix * vec4(vertexPosition, 1.0);\n  gl_Position = pMatrix * vertexCamSpace;\n\n  vec3 camPosition = (inverse(vMatrix) * vec4(0,0,0,1.0)).xyz;\n\n  fragmentPosition = (mMatrix * vec4(vertexPosition,1.0)).xyz;\n  fragmentNormal = normalize((transpose(inverse(mMatrix))* vec4(vertexNormal, 1.0)).xyz);\n  viewDirection = normalize(camPosition - fragmentPosition);\n  lightDirection = normalize(lightPosition - fragmentPosition);\n}"},"fragment":{"source":"#version 300 es\n\n// For better performance less precision\nprecision highp float;\n\nin vec3 fragmentPosition;\nin vec3 fragmentNormal;\nin vec3 viewDirection;\nin vec3 lightDirection;\n\n\nout vec4 fragColor;\n\n// Base Color\nuniform vec3 baseColor;\n// Light Color\nuniform vec3 lightColor;\n\nuniform bool change;\nuniform bool flatShading;\n\nfloat lambertianDiffuse(vec3 n, vec3 l){\n  return clamp(dot(n, l), 0.0, 1.0);\n}\n\nfloat specularGourad(vec3 n, vec3 l, vec3 v, float s){\n  vec3 r = normalize(2.0 * dot(n,l) * n - l);\n  return clamp(pow(clamp(dot(r, v), 0.0, 1.0), s), 0.0, 1.0);\n}\n\nfloat specularBlinn(vec3 n, vec3 l, vec3 v, float s){\n  vec3 h = normalize(v + l);\n  return pow(clamp(dot(h, n), 0.0, 1.0), s);\n}\n\n// Main program for each fragment = pixel candidate\nvoid main() {\n  float kD = 1.0;\n  float kS = 0.5;\n  float kA = 0.5;\n  float s = 20.0;\n\n  vec3 n;\n\n  if(flatShading){\n    n = normalize(cross(dFdx(fragmentPosition), dFdy(fragmentPosition)));\n  } else {\n    n = fragmentNormal;\n  }\n\n  float Id = lambertianDiffuse(n, lightDirection);\n  float Is;\n  if(change){\n    Is = specularGourad(n, lightDirection, viewDirection, s);\n  } else {\n    s *= 4.0;\n    Is = specularBlinn(n, lightDirection, viewDirection, s);\n  }\n  \n  float Ia = kA;\n\n  vec3 color = ((kA*Ia + kD * Id)* baseColor + kS*Is)* lightColor;\n\n  fragColor = vec4(color, 1.0);\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"lightPosition":{"value":[24,14,-31]},"baseColor":{"value":[1,0,0]},"lightColor":{"value":[1,1,1]},"change":{"value":[true]},"flatShading":{"value":[true]}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"#version 300 es\n\n// Vertex coordinates in object space for the render quad\nin vec3 vertexPosition;\n// Texture coordinate for this vertex and the render quad\nin vec2 vertexTextureCoordinates;\n\n// Texture coordinate needs to be passed on to the R2T fragment shader\nout vec2 fragmentTextureCoordinates;\n\n// Main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertexPosition, 1.0);\n  fragmentTextureCoordinates = vertexTextureCoordinates;\n}"},"fragment":{"source":"#version 300 es\n\nprecision highp float;\n\n// A texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n// Texture coordinates coming from the vertex shader, interpolated through the rasterizer\nin vec2 fragmentTextureCoordinates;\nout vec4 fragColor;\n\n// Main program for each fragment of the render quad\nvoid main() {\n  fragColor = texture(textureRendered, fragmentTextureCoordinates.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}